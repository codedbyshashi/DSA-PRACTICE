//BRUTE FORCE
class Solution {
    public int subarraysWithXorK(int[] nums, int k) {
        int n = nums.length;
        int count = 0;

        for(int i=0;i<n;i++){
            for(int j=i;j<n;j++){
                int xor =0;
                for(int g=i;g<=j;g++){
                    xor = xor^nums[g];
                   
                }
                 if(xor == k) count++;

            }
        }
        return count;
      
    }
}
//BETTER APPROACH
class Solution {
  public int subarraysWithXorK(int[] nums, int k) {
    int n = nums.length;
    int count = 0;

    for (int i = 0; i < n; i++) {
      int xor = 0;
      for (int j = i; j < n; j++) {
        xor = xor ^ nums[j];
        if (xor == k) count++;
      }
    }
    return count;
  }
}
//OPTIMAL APPROACH
class Solution {
  public int subarraysWithXorK(int[] nums, int k) {
    int n = nums.length;
    int xr = 0;
    int count = 0;
    Map<Integer, Integer> mpp = new HashMap<>();
    mpp.put(0, 1);

    for (int i = 0; i < n; i++) {
      xr ^= nums[i];
      int x = xr ^ k;
      count += mpp.getOrDefault(x, 0);
      mpp.put(xr, mpp.getOrDefault(xr, 0) + 1);
    }
    return count;
  }
}
